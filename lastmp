#!/usr/bin/python

# TODO:

# * mpdclient doesn't expose MBIDs if we've got 'em. Should fix that, as soon
#   as MPD 0.12 is out.

import sys
import os
import time
import getopt
import signal

import mpdclient2
import lastfm
import lastfm.logger

"""This program connects to MPD and runs in the background. When a valid
song is played (valid = must be tagged, played w/o skipping for the
first 50% or 240s), it invokes lastfmsubmit, which will submit the song
to Last.fm."""

DEF_SLEEP = 5
PIDFILE = os.path.join(lastfm.PID_DIR, 'lastmp.pid')

# If the system load is high, we may not wake again until slightly
# longer than we slept. This should really be like 0.1, but
# unfortunately MPD only reports times with a resolution of 1 second.

FUZZ = 1

class Song:
    def __init__(self, mpdclientsongobj):
        # Warning: mpdclient2 is rather confused about whether these are
        # attributes or keys or what. Hence the funny exceptions.
        try:
            self.artist = mpdclientsongobj.artist
        except (AttributeError, KeyError):
            self.artist = None
        try:
            self.title = mpdclientsongobj.title
        except (AttributeError, KeyError):
            self.title = None
        try:
            self.album = mpdclientsongobj.album
        except (AttributeError, KeyError):
            self.album = None
        try:
            self.time = mpdclientsongobj.time
        except (AttributeError, KeyError):
            self.time = None
        try:
            self.file = mpdclientsongobj.file
        except (AttributeError, KeyError):
            self.file = None

    def __eq__(self, other):
        if other == None:
            return False
        else:
            return self.file == other.file or (
                self.artist == other.artist and self.title == other.title and
                self.album == other.album and self.time == other.time)

    # O RLY?
    def __ne__(self, other):
        # YA RLY!
        return not self == other

    # NO WAI!!!
    def __str__(self):
        return '%s - %s [%d:%02d]' % ((self.artist, self.title) +
            divmod(int(self.time), 60))

class MpdObserver:
    def __init__(self, sleep, mpd_args, debug):
        global log

        self.sleep = sleep
        self.debug = debug
        self.children = []

        try:
            self.mpd = mpdclient2.connect(**mpd_args)
            log.info('Connected to MPD')
        except (EOFError, mpdclient2.socket.error):
            self.mpd = None
            log.warning('Could not connect to MPD')

        self.prevstatus = None
        self.prevsong = None
        self.prevtime = None
        self.skipped = False
        self.submitted = False
        self.played_enough = False

    def wake(self):
        global log

        status = self.mpd.do.status()
        currentsong = Song(self.mpd.do.currentsong())

        if self.prevstatus is None or status.state != self.prevstatus.state:
            if status.state == 'stop':
                log.debug('Changed state: stopped')
            if status.state == 'play':
                log.debug('Changed state: playing')
            if status.state == 'pause':
                log.debug('Changed state: paused')

        if status.state in ('play', 'pause'):
            time, l = map(float, status.time.split(':'))
            if status.state == 'play':
                if currentsong != self.prevsong or \
                        self.prevstatus.state == 'stop':
                    log.info('New song: %s', currentsong)
                    if (self.prevsong and time > self.sleep +
                            FUZZ + int(status.xfade)) or \
                            (self.prevsong is None and
                            time/l > lastfm.SUB_PERCENT or
                            time > lastfm.SUB_SECONDS):
                        log.warning(
                            'Started at %d, will not submit' % time)
                        self.skipped = True
                    else:
                        self.skipped = False
                        self.submitted = False
                        self.played_enough = False
                else:
                    if self.prevtime and time < self.sleep + FUZZ and \
                            (self.prevtime/l >= lastfm.SUB_PERCENT or \
                            self.prevtime >= lastfm.SUB_SECONDS):
                        log.info('Restarted song')
                        self.skipped = False
                        self.submitted = False
                        self.played_enough = False
                    if self.prevtime and \
                            time > self.prevtime + self.sleep + FUZZ:
                        log.warning(
                            'Skipped from %d to %d' %
                            (self.prevtime, time))
                        self.skipped = True
                    if not self.skipped and not self.played_enough and \
                            l >= lastfm.MIN_LEN and l <= lastfm.MAX_LEN and \
                            (time/l >= lastfm.SUB_PERCENT or \
                            time >= lastfm.SUB_SECONDS):
                        log.debug('OK, %d of %d seconds played' % (time, l))
                        self.played_enough = True
                    if not self.submitted and not self.skipped and \
                            self.played_enough:
                        pid = self.submit(currentsong)
                        if pid:
                            self.children.append(pid)
                        self.submitted = True
        else:
            time = None

        self.prevsong = currentsong
        self.prevstatus = status
        self.prevtime = time

    def observe(self):
        global log

        """Loop forever, periodically checking MPD's state and
        submitting songs when necessary."""
        while True:
            if self.mpd is None:
                try:
                    self.mpd = mpdclient2.connect()
                    log.warning('(Re)connected to MPD')
                except (EOFError, mpdclient2.socket.error):
                    pass
            # OK, we're connected. Check this first...
            for pid in self.children:
                try:
                    pid, status = os.waitpid(pid, os.WNOHANG)
                    if pid:
                        if os.WEXITSTATUS(status) == 0:
                            log.debug('child %d exited successfully' % pid)
                        else:
                            log.warning('child %d failed with status %d' %
                                (pid, status))
                except OSError:
                    pass
            # But don't do anything else here, because we guarantee that as
            # long as we are connected, sucessive calls to wake() will happen
            # no more than sleep + FUZZ seconds apart. (When mpd is latency is
            # extremely high, e.g. when doing an db update on an already
            # heavily loaded machine, this unfortunately may not be true).
            if self.mpd:
                try:
                    self.wake()
                except (EOFError, mpdclient2.socket.error):
                    log.warning('Lost connection to MPD')
                    self.mpd = None
                    self.prevsong = None
                    self.prevstatus = None
                    self.prevtime = None
            time.sleep(self.sleep)

    def submit(self, song):
        global log

        if song.artist and song.title and song.time:
            log.info('Sending to daemon')
            try:
                pid = os.fork()
                if pid == 0:
                    args = [
                        'lastfmsubmit', '--quiet',
                        '--artist', song.artist,
                        '--title', song.title,
                        '--length', song.time
                        ]
                    if song.album:
                        args += ['--album', song.album]
                    #if song.mbid:
                    #    args += ['--mbid', song.album]
                    if self.debug:
                        args += ['--debug']
                    log.debug('Exec %s' % ' '.join(args))
                    os.execvp('lastfmsubmit', args)
                else:
                    return pid
            except OSError:
                log.warning('Could not fork')
        else:
            log.error('File %s is missing artist or title or length' %
                song.file)

def daemon():
    global log

    if fork:
        try:
            pid = os.fork()
            if pid != 0: sys.exit(0)
        except OSError, e:
            print >>sys.stderr, 'fork: %s' % e
            sys.exit(1)

    log.info('LastMP starting')
    pidfile = open(PIDFILE, 'w')
    print >>pidfile, os.getpid()
    pidfile.close()

    def shutdown(signum, frame):
        log.info('Caught signal %d, exiting' % signum)
        os.remove(PIDFILE)
        os._exit(0)

    signal.signal(signal.SIGTERM, shutdown)
    signal.signal(signal.SIGINT, shutdown)

    mo = MpdObserver(sleep, mpd_args, debug)
    # Even if we couldn't connect, start the observe loop anyway.
    # Perhaps MPD failed at boot and the admin will fix it later.
    mo.observe()

if __name__ == '__main__':
    global log
    os.umask(002)

    shortopts = 's:h:p:o:dn'
    longopts = ['sleep=', 'host=', 'password=', 'port=', 'debug', 'no-daemon']

    try:
        opts, args = getopt.getopt(sys.argv[1:], shortopts, longopts)
    except getopt.GetoptError, e:
        print >>sys.stderr, 'getopt: %s' % e
        sys.exit(1)

    sleep = DEF_SLEEP
    mpd_args = {}
    debug = False
    fork = True

    for opt, arg in opts:
        if opt in ('--sleep', '-s'):
            sleep = int(arg)
            if sleep >= lastfm.MIN_LEN / 2:
                print >>sys.stderr, 'sleep: %d is too big' % sleep
                sys.exit(1)
        elif opt in ('--host', '-h'):
            mpd_args['host'] = arg
        elif opt in ('--password', '-p'):
            mpd_args['password'] = arg
        elif opt in ('--port', '-o'):
            mpd_args['port'] = arg
        elif opt in ('--debug', '-d'):
            debug = True
        elif opt in ('--no-daemon', '-n'):
            fork = False

    try:
        log = lastfm.logger.getlog('lastmp', lastfm.LOGFILE, debug)
    except IOError, e:
        print >>sys.stderr, 'log: %s' % e
        sys.exit(1)

    try:
        daemon()
    except SystemExit, e:
        sys.exit(e.args[0])
    except:
        import traceback
        e = traceback.format_exception(*sys.exc_info())
        log.error('Aborting: %s' % e)
        sys.exit(1)
