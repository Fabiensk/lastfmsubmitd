#!/usr/bin/python

# TODO:

# * mpdclient doesn't expose MBIDs if we've got 'em. Should fix that, as soon
#   as MPD 0.12 is out.

import sys
import os
import time
import getopt
import signal

import mpdclient2
import lastfm
import lastfm.logger
import lastfm.queue
import lastfm.marshaller

"""This program connects to MPD and runs in the background. When a valid
song is played (valid = must be tagged, played w/o skipping for the
first 50% or 240s), it invokes lastfmsubmit, which will submit the song
to Last.fm."""

DEF_SLEEP = 5
PIDFILE = os.path.join(lastfm.PID_DIR, 'lastmp.pid')

# If the system load is high, we may not wake again until slightly
# longer than we slept. This should really be like 0.1, but
# unfortunately MPD only reports times with a resolution of 1 second.

FUZZ = 1

class Song:
    def __init__(self, sobj):
        self.artist = getattr(sobj, 'artist', '')
        self.title = getattr(sobj, 'title', '')
        self.album = getattr(sobj, 'album', '')
        self.length = int(getattr(sobj, 'time', 0))
        self.file = getattr(sobj, 'file', '')

    def __eq__(self, other):
        if other == None:
            return False
        else:
            return self.file == other.file or \
                (self.artist == other.artist and self.title == other.title and
                self.album == other.album and self.length == other.length)

    # O RLY?
    def __ne__(self, other):
        # YA RLY!
        return not self == other

    def __str__(self):
        time = '%d:%02d' % divmod(self.length, 60)
        if self.artist and self.title:
            return '%s - %s [%s]' % (self.artist, self.title, time)
        else:
            return '%s [%s]' % (self.file, time)

    def dict(self):
        d = {
            'time': time.gmtime(),
            'artist': lastfm.marshaller.guess(self.artist, 'utf-8'),
            'title': lastfm.marshaller.guess(self.title, 'utf-8'),
            'length': self.length,
            }
        if self.album:
            d['album'] = lastfm.marshaller.guess(self.album, 'utf-8')
        for reqd in ('artist', 'title', 'length'):
            if not d[reqd]:
                raise ValueError('%s is missing %s' % (self.file, reqd))
        else:
            return d

class MpdObserver:
    def __init__(self, log, sleep, mpd_args, debug):
        self.log = log
        self.sleep = sleep
        self.debug = debug
        self.kids = []

        try:
            self.mpd = mpdclient2.connect(**mpd_args)
            self.log.info('Connected to MPD')
        except (EOFError, mpdclient2.socket.error):
            self.mpd = None
            self.log.warning('Could not connect to MPD')

        self.prevstatus = None
        self.prevsong = None
        self.prevpos = None
        self.skipped = False
        self.submitted = False
        self.played_enough = False

    def wake(self):
        status = self.mpd.do.status()
        song = Song(self.mpd.do.currentsong())

        if not self.prevstatus or status.state != self.prevstatus.state:
            self.log.debug('Changed state: %s' % status.state)

        if status.state in ('play', 'pause'):
            pos, length = map(float, status.time.split(':'))
            if status.state == 'play':
                if song != self.prevsong or \
                        self.prevstatus.state == 'stop':
                    self.log.info('New song: %s', song)
                    if (self.prevsong and pos > self.sleep +
                            FUZZ + int(status.xfade)) or \
                            (self.prevsong is None and
                            pos/length > lastfm.SUB_PERCENT or
                            pos > lastfm.SUB_SECONDS):
                        self.log.warning(
                            'Started at %d, will not submit' % pos)
                        self.skipped = True
                    else:
                        self.skipped = False
                        self.submitted = False
                        self.played_enough = False
                else:
                    if self.prevpos and pos < self.sleep + FUZZ and \
                            (self.prevpos/length >= lastfm.SUB_PERCENT or \
                            self.prevpos >= lastfm.SUB_SECONDS):
                        self.log.info('Restarted song')
                        self.skipped = False
                        self.submitted = False
                        self.played_enough = False
                    if self.prevpos and \
                            pos > self.prevpos + self.sleep + FUZZ:
                        self.log.warning(
                            'Skipped from %d to %d' %
                            (self.prevpos, pos))
                        self.skipped = True
                    if not self.skipped and not self.played_enough and \
                            length >= lastfm.MIN_LEN and \
                            length <= lastfm.MAX_LEN and \
                            (pos >= lastfm.SUB_SECONDS or \
                            pos/length >= lastfm.SUB_PERCENT):
                        self.log.debug('OK, %d/%d played' % (pos, length))
                        self.played_enough = True
                    if not self.submitted and not self.skipped and \
                            self.played_enough:
                        pid = self.submit(song)
                        if pid: self.kids.append(pid)
                        self.submitted = True
        else:
            pos = None

        self.prevsong = song
        self.prevstatus = status
        self.prevpos = pos

    def observe(self):
        """Loop forever, periodically checking MPD's state and
        submitting songs when necessary."""
        while True:
            if self.mpd is None:
                try:
                    self.mpd = mpdclient2.connect()
                    self.log.warning('Connected to MPD')
                except (EOFError, mpdclient2.socket.error):
                    pass
            # OK, we're connected. Check this first...
            for pid in self.kids:
                try:
                    pid, status = os.waitpid(pid, os.WNOHANG)
                    if pid:
                        if os.WEXITSTATUS(status) == 0:
                            self.log.debug('Child %d exited' % pid)
                        else:
                            self.log.warning('Child %d failed (%d)' %
                                (pid, status))
                except OSError:
                    pass
            # But don't do anything else here, because we guarantee that as
            # long as we are connected, sucessive calls to wake() will happen
            # no more than sleep + FUZZ seconds apart. (When mpd is latency is
            # extremely high, e.g. when doing an db update on an already
            # heavily loaded machine, this unfortunately may not be true).
            if self.mpd:
                try:
                    self.wake()
                except (EOFError, mpdclient2.socket.error):
                    self.log.warning('Lost connection to MPD')
                    self.mpd = None
                    self.prevsong = None
                    self.prevstatus = None
                    self.prevpos = None
            time.sleep(self.sleep)

    def submit(self, song):
        try:
            sub = song.dict()
            pid = os.fork()
            if pid == 0:
                self.log.info('Sending to daemon')
                fifo = lastfm.queue.Writer(self.log, lastfm.FIFO, lastfm.LOCK)
                print >>fifo, lastfm.marshaller.dump(sub)
                sys.exit(0)
            else:
                return pid
        except ValueError, e:
            self.log.error('Missing tags: %s' % e)
        except OSError:
            self.log.error('Could not fork')

def daemon(log, fork):
    if fork:
        try:
            pid = os.fork()
            if pid != 0: sys.exit(0)
        except OSError, e:
            print >>sys.stderr, 'fork: %s' % e
            sys.exit(1)

    log.info('LastMP starting')
    pidfile = open(PIDFILE, 'w')
    print >>pidfile, os.getpid()
    pidfile.close()

    def shutdown(signum, frame):
        log.info('Caught signal %d, exiting' % signum)
        os.remove(PIDFILE)
        os._exit(0)

    signal.signal(signal.SIGTERM, shutdown)
    signal.signal(signal.SIGINT, shutdown)

    mo = MpdObserver(log, sleep, mpd_args, debug)

    # Even if we couldn't connect, start the observe loop anyway.
    # Perhaps MPD failed at boot and the admin will fix it later.
    mo.observe()

if __name__ == '__main__':
    os.umask(002)

    shortopts = 's:h:p:o:dn'
    longopts = ['sleep=', 'host=', 'password=', 'port=', 'debug', 'no-daemon']

    try:
        opts, args = getopt.getopt(sys.argv[1:], shortopts, longopts)
    except getopt.GetoptError, e:
        print >>sys.stderr, 'getopt: %s' % e
        sys.exit(1)

    sleep = DEF_SLEEP
    mpd_args = {}
    debug = False
    fork = True

    for opt, arg in opts:
        if opt in ('--sleep', '-s'):
            sleep = int(arg)
            if sleep >= lastfm.MIN_LEN / 2:
                print >>sys.stderr, 'sleep: %d is too big' % sleep
                sys.exit(1)
        elif opt in ('--host', '-h'):
            mpd_args['host'] = arg
        elif opt in ('--password', '-p'):
            mpd_args['password'] = arg
        elif opt in ('--port', '-o'):
            mpd_args['port'] = arg
        elif opt in ('--debug', '-d'):
            debug = True
        elif opt in ('--no-daemon', '-n'):
            fork = False

    try:
        log = lastfm.logger.getlog('lastmp', lastfm.LOG, debug)
    except IOError, e:
        print >>sys.stderr, 'log: %s' % e
        sys.exit(1)

    try:
        daemon(log, fork)
    except SystemExit, e:
        sys.exit(e.args[0])
    except:
        import traceback
        einfo = traceback.format_exception(*sys.exc_info())
        log.error('Aborting: %s' % ''.join(einfo))
        sys.exit(1)
