#!/usr/bin/python

import sys
import os
import time
import getopt
import socket
import urllib
import md5
import signal

import lastfm
import lastfm.logger
import lastfm.marshaller
import lastfm.queue

SLEEP_TIME = 15
FIFO_TIMEOUT = 5
PIDFILE = os.path.join(lastfm.PID_DIR, 'lastfmsubmitd.pid')

CLIENT_ID = 'lsd'
CLIENT_VERSION = '0.25'

PROTOCOL_VERSION = '1.1'
HANDSHAKE_URL_BASE = 'http://post.audioscrobbler.com/'
DEF_INTERVAL = 1
SUB_CHUNK_SIZE = 10

# This should be something small, because the server times out quickly. If
# there is any congestion at either end of the network, it will give up and
# try to process a partial read, leading to "not all request variables set"
# errors. So, there is little point in waiting around for the rest of the data
# to get there. Of course, we don't want to time out *faster* than the server
# does, because after a timeout we assume none of the subs went through at all
# and will thus retry all of them. If half of the subs were actually read this
# will lead to duplicate submits which will then have to be dropped by the
# spam filter.

HTTP_TIMEOUT = 30

# This, on the other hand, is totally arbitrary.

INITIAL_BACKOFF = 60

class HandshakeError(Exception): pass
class SubTimeoutError(Exception): pass
class SessionError(Exception): pass
class InvalidSubError(Exception): pass

class SessionThrottle:
    """Very simple throttler that ensures we sleep long enough between network
    requests, but lets you sleep a little at a time and then wake to do other
    stuff. Only keeps track of how long it has slept, not the actual time
    elapsed. You can mess with time.slept to simulate a sleep."""

    def __init__(self, log):
        self.log = log
        self.reset()

    def reset(self):
        self.slept = 0
        self.sleep_until = 0

    def ready(self):
        return self.slept >= self.sleep_until

    def backoff(self):
        self.slept = 0
        if self.sleep_until < INITIAL_BACKOFF:
            self.sleep_until = INITIAL_BACKOFF
        else:
            if self.sleep_until < 6 * 3600:
                self.sleep_until *= 2
        self.log.info('Backing off, will retry in %d:%02d' %
            divmod(self.sleep_until, 60))

    def sleep(self, secs):
        secs = min(secs, self.sleep_until - self.slept)
        time.sleep(secs)
        self.slept += secs

class LastFmSession:
    def __init__(self, log, user, password):
        self.log = log
        self.user = user
        self.password = password
        self.connected = False
        self.interval = DEF_INTERVAL
        self.uncommitted_subs = []
        self.handshake_url = self.make_handshake_url(user)
        self.submit_url = None

    def make_handshake_url(self, user):
        args = {
            'hs': 'true',
            'p': PROTOCOL_VERSION,
            'c': CLIENT_ID,
            'v': CLIENT_VERSION,
            'u': user,
            }
        return '?'.join([HANDSHAKE_URL_BASE, urllib.urlencode(args)])

    def handshake(self):
        self.log.debug('Handshake URL: %s' % self.handshake_url)

        try:
            signal.alarm(HTTP_TIMEOUT)
            response = urllib.urlopen(self.handshake_url)
            status_line = response.readline().strip()
            signal.alarm(0)
        # XXX: handshaketimeouterror?
        except IOError, e:
            signal.alarm(0)
            raise HandshakeError(e)

        if status_line == 'UPTODATE':
            self.read_submit_url(response)
        elif status_line.startswith('UPDATE'):
            try:
                msg, url = status_line.split(' ', 1)
                self.log.warning('Plugin is out of date: %s' % msg)
                self.log.info('Please go to %s to upgrade' % url)
            except ValueError:
                self.log.warning('Plugin is out of date')
            self.read_submit_url(response)
        elif status_line == 'BADUSER':
            raise HandshakeError('bad username')
        elif status_line.startswith('FAILED'):
            try:
                failed, reason = status_line.split(' ', 1)
            except ValueError:
                reason = 'unknown: "%s"' % status_line
            raise HandshakeError(reason)
        else:
            raise HandshakeError('could not parse response: %s' % status_line)

        self.connected = True
        self.read_interval(response)
        time.sleep(self.interval)

    def read_submit_url(self, response):
        challenge = response.readline().strip()
        self.session_key = self.digest(challenge)
        self.submit_url = response.readline().strip()
        self.log.info('Handshake sucessful')
        self.log.debug('Submit URL: %s' % self.submit_url)

    def read_interval(self, response):
        interval_line = response.readline().strip()
        if interval_line and interval_line.startswith('INTERVAL'):
            msg, secs = interval_line.split(' ', 1)
            interval = int(secs)
            if interval != self.interval:
                self.log.debug('Session interval changed to %d' % interval)
                self.interval = interval

    def digest(self, challenge):
        pass_hash = md5.new(self.password)
        sess_hash = md5.new(pass_hash.hexdigest() + challenge)
        return sess_hash.hexdigest()

    def submit(self, cache):
        while cache.subs:
            chunk = cache.subs[:SUB_CHUNK_SIZE]
            self.log.info('Submitting %d song(s)' % len(chunk))

            args = { 'u': self.user, 's': self.session_key }
            post_data = [urllib.urlencode(args)]
            for i, sub in enumerate(chunk):
                args = {}
                args['a[%d]'%i] = sub['artist'].encode('utf-8')
                args['t[%d]'%i] = sub['title'].encode('utf-8')
                args['l[%d]'%i] = sub['length']
                args['i[%d]'%i] = time.strftime(lastfm.TIME_FMT, sub['time'])
                try:
                    args['b[%d]' % i] = sub['album'].encode('utf-8')
                except KeyError:
                    args['b[%d]' % i] = ''
                try:
                    args['m[%d]' % i] = sub['mbid'].encode('utf-8')
                except KeyError:
                    args['m[%d]' % i] = ''
                self.log.debug('Submitting: %s' % lastfm.logger.repr(sub))
                post_data.append(urllib.urlencode(args))

            post_str = '&'.join(post_data)
            self.log.debug('POST data: %s' % post_str)
            try:
                signal.alarm(HTTP_TIMEOUT)
                response = urllib.urlopen(self.submit_url, post_str)
                signal.alarm(0)
            except (IOError, AttributeError), e:
                # The AttributeError is some bizarre urllib bug where
                # http_error_default tries to make an addinfourl with an fp
                # that's actually None. I have no idea. It should be IOError.
                signal.alarm(0)
                raise SubTimeoutError(e)

            failed = False
            status_line = response.readline().strip()

            if status_line == 'OK':
                self.log.info('Submission(s) accepted')
                # Now, and only now, we do our side effect.
                cache.subs = cache.subs[SUB_CHUNK_SIZE:]
            elif status_line == 'BADAUTH':
                self.connected = False
                raise SessionError('incorrect password')
            elif status_line.startswith('FAILED'):
                try:
                    failed, reason = status_line.split(' ', 1)
                except ValueError:
                    reason = 'unknown: "%s"' % status_line
                raise InvalidSubError(reason)
            else:
                raise InvalidSubError('could not parse response: %s' %
                    status_line)

            self.read_interval(response)
            time.sleep(self.interval)

class SubCache:
    """Holds submissions while we are running, and saves them to persistent
    storage on exit."""

    def __init__(self, log, filename):
        self.log = log
        self.subs = []
        try:
            input = file(filename)
            for doc in lastfm.marshaller.load_documents(input.read()):
                try:
                    self.add(doc)
                except ValueError, e:
                    self.log.warning('Invalid cache, ignoring: %s' % e)
        except IOError:
            pass

    def add(self, sub):
        for required in ('artist', 'title', 'length'):
            if not sub.has_key(required) or not sub[required]:
                raise ValueError('missing %s' % required)
        else:
            self.subs.append(sub)

    def dump(self, filename):
        try:
            self.log.info('Saving %d sub(s) to cache' % len(self.subs))
            output = file(filename, 'w')
            lastfm.marshaller.dump_documents(self.subs, output)
            self.subs = []
        except IOError:
            self.log.error('Cannot write to %s, discarding %d sub(s)' %
                (filename, len(self.subs)))

def daemon(log, fork, usenetwork):
    if fork:
        try:
            pid = os.fork()
            if pid != 0: sys.exit(0)
        except OSError, e:
            print >>sys.stderr, 'fork: %s' % e
            sys.exit(1)

    log.info('Last.fm Submission Daemon starting')
    pidfile = open(PIDFILE, 'w')
    print >>pidfile, os.getpid()
    pidfile.close()

    def shutdown(signum, frame):
        log.info('Caught signal %d, exiting' % signum)
        cache.dump(lastfm.CACHE)
        os.remove(PIDFILE)
        os._exit(0)

    def alarm(signum, frame):
        log.info('Caught signal %d, resuming' % signum)

    def reinit(signum, frame):
        # XXX: reread config, reopen log, reset throttle, rehandshake
        pass

    signal.signal(signal.SIGTERM, shutdown)
    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGHUP, reinit)
    signal.signal(signal.SIGALRM, alarm)

    session = LastFmSession(log, user, password)
    throttle = SessionThrottle(log)
    fifo = lastfm.queue.Reader(log)
    cache = SubCache(log, lastfm.CACHE)

    if cache.subs:
        log.info('Read %d sub(s) from cache', len(cache.subs))

    while True:
        if usenetwork and not session.connected:
            if throttle.ready():
                try:
                    session.handshake()
                    throttle.reset()
                except HandshakeError, e:
                    log.error('Handshake failed: %s' % e)
                    throttle.backoff()
            else:
                throttle.sleep(SLEEP_TIME)

        if session.connected and cache.subs:
            if throttle.ready():
                try:
                    log.debug('Attempting submit, %d sub(s)' %
                        len(cache.subs))
                    session.submit(cache)
                    log.debug('Done, %d remain in cache' % len(cache.subs))
                    throttle.reset()
                except SessionError, e:
                    log.error('Session failed: %s' % e)
                    throttle.backoff()
                except InvalidSubError, e:
                    log.error('Submission failed: %s' % e)
                    throttle.backoff()
                except SubTimeoutError:
                    log.error('Submission timed out')
                    throttle.backoff()
            else:
                throttle.sleep(SLEEP_TIME)

        read = []
        data = fifo.select(FIFO_TIMEOUT)
        while data:
            # We may have timed out for a few seconds, but whatever.
            read.append(data)
            data = fifo.select(FIFO_TIMEOUT)
        else:
            # We did time out, so adjust the throttle accordingly.
            throttle.slept += FIFO_TIMEOUT
        if read:
            for doc in lastfm.marshaller.load_documents(''.join(read)):
                try:
                    cache.add(doc)
                    log.debug('Added %s' % lastfm.logger.repr(doc))
                except ValueError, e:
                    log.error('Invalid data, discarding: %s' % e)

if __name__ == '__main__':
    os.umask(002)

    shortopts = 'u:p:dnl'
    longopts = ['user=', 'password=', 'debug', 'no-daemon', 'no-network']

    try:
        opts, args = getopt.getopt(sys.argv[1:], shortopts, longopts)
    except getopt.GetoptError, e:
        print >>sys.stderr, 'getopt: %s' % e
        sys.exit(1)

    user = None
    password = None
    debug = False
    fork = True
    usenetwork = True

    try: user = os.environ['LASTFM_USER']
    except KeyError: pass
    try: password = os.environ['LASTFM_PASSWORD']
    except KeyError: pass

    for opt, arg in opts:
        if opt in ('--user', '-u'):
            user = arg
        elif opt in ('--password', '-p'):
            password = arg
        elif opt in ('--debug', '-d'):
            debug = True
        elif opt in ('--no-daemon', '-n'):
            fork = False
        elif opt in ('--no-network', '-l'):
            usenetwork = False

    if not (user and password):
        print >>sys.stderr, 'account: need user and password'
        sys.exit(1)

    try:
        log = lastfm.logger.getlog('lastfmsubmitd', lastfm.LOG, debug)
    except IOError, e:
        print >>sys.stderr, 'log: %s' % e
        sys.exit(1)

    try:
        daemon(log, fork, usenetwork)
    except SystemExit, e:
        sys.exit(e.args[0])
    except:
        import traceback
        einfo = traceback.format_exception(*sys.exc_info())
        log.error('Aborting: %s' % ''.join(einfo))
        sys.exit(1)
