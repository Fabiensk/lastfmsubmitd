#!/usr/bin/python

import sys
import os
import stat
import time
import getopt
import select
import urllib
import md5
import signal

import lastfm
import lastfm.logger
import lastfm.asyaml

CLIENT_ID = "lsd"
CLIENT_VERSION = "0.7"
PROTOCOL_VERSION = "1.1"

HANDSHAKE_URL_BASE = "http://post.audioscrobbler.com/"
DEF_INTERVAL = 1

SUB_CHUNK_SIZE = 10

SLEEP_TIME = 15
INITIAL_BACKOFF = 60

FIFO_TIMEOUT = 5

class HandshakeError(Exception): pass
class SubTimeoutError(Exception): pass
class SessionError(Exception): pass
class InvalidSubError(Exception): pass

class SessionThrottle:
    """Very simple throttle class that ensures we sleep long enough between
    network requests. If something fails, the time it takes to be 'ready' can
    be increased. Please note, this class does not take into account any other
    sleeping that may be going on (such as in fifo.select). Use the add method
    if you want it to."""

    def __init__(self, log):
        self.log = log
        self.reset()

    def reset(self):
        self.slept = 0
        self.sleep_until = 0

    def ready(self):
        return self.slept >= self.sleep_until

    def backoff(self):
        self.slept = 0
        if self.sleep_until < INITIAL_BACKOFF:
            self.sleep_until = INITIAL_BACKOFF
        else:
            self.sleep_until *= 2
        self.log.info("Backing off, will retry in %d secs" % self.sleep_until)

    def sleep(self, secs):
        time.sleep(secs)
        self.slept += secs

    def add(self, secs):
        self.slept += secs

class SubCache:
    def __init__(self, log, filename):
        self.log = log
        self.subs = []
        try:
            cache = file(filename)
            stored = lastfm.asyaml.Parser(cache.read())
            for sub in stored.parse():
                self.subs.append(sub)
        except IOError:
            pass

    def dump(self, filename):
        try:
            log.info("Saving %d subs to cache" % len(cache.subs))
            out = file(filename, 'w')
            out.write("\n".join(map(str, self.subs)))
            out.write("\n")
            self.subs = []
        except IOError:
            self.log.error("Cannot write to %s, discarding %d subs" %
                (filename, len(self.subs)))

class SubFifo:
    def __init__(self, log, fifoname):
        self.log = log
        self.fifoname = fifoname
        try:
            if not stat.S_ISFIFO(os.stat(fifoname).st_mode):
                self.log.error("%s exists but is not a fifo, exiting")
                sys.exit(1)
        except OSError:
            self.log.debug("Creating %s" % fifoname)
            os.mkfifo(self.fifoname)

    def select(self, timeout):
        fd = os.open(self.fifoname, os.O_NONBLOCK)
        data = []
        rx, wx, ex = select.select([fd], [], [], timeout)
        while fd in rx:
            chunk = os.read(fd, 4096)
            if chunk:
                self.log.debug("Read %d bytes" % len(chunk))
                data.append(chunk)
                rx, wx, ex = select.select([fd], [], [], timeout)
            else:
                rx, wx, ex = [], [], []
        os.close(fd)
        return ''.join(data)

class LastFmSession:
    def __init__(self, log, user, password):
        self.log = log
        self.user = user
        self.password = password
        self.connected = False
        self.interval = DEF_INTERVAL
        self.uncommitted_subs = []
        self.handshake_url = self.make_handshake_url(user)
        self.submit_url = None

    def make_handshake_url(self, user):
        args = {
            'hs': 'true',
            'p': PROTOCOL_VERSION,
            'c': CLIENT_ID,
            'v': CLIENT_VERSION,
            'u': user,
            }
        return "?".join([HANDSHAKE_URL_BASE, urllib.urlencode(args)])

    def handshake(self):
        self.log.debug("Handshake URL: %s" % self.handshake_url)

        try:
            response = urllib.urlopen(self.handshake_url)
            status_line = response.readline().strip()
        except IOError, e:
            raise HandshakeError(e)

        if status_line == "UPTODATE":
            self.read_submit_url(response)
        elif status_line.startswith("UPDATE"):
            try:
                msg, url = status_line.split(" ")
                self.log.warning("Plugin is out of date: %s" % msg)
                self.log.info("Please go to %s to upgrade" % url)
            except ValueError:
                self.log.warning("Plugin is out of date")
            self.read_submit_url(response)
        elif status_line == "BADUSER":
            raise HandshakeError("bad username")
        elif status_line.startswith("FAILED"):
            try:
                failed, reason = status_line.split(" ")
            except ValueError:
                reason = "unknown"
            raise HandshakeError("failed: %s" % reason)
        else:
            raise HandshakeError("could not parse response: %s" % status_line)

        self.connected = True
        self.read_interval(response)
        time.sleep(self.interval)

    def read_submit_url(self, response):
        challenge = response.readline().strip()
        self.session_key = self.digest(challenge)
        self.submit_url = response.readline().strip()
        self.log.info("Handshake sucessful")
        self.log.debug("Submit URL: %s" % self.submit_url)

    def read_interval(self, response):
        interval_line = response.readline().strip()
        if interval_line and interval_line.startswith("INTERVAL"):
            msg, secs = interval_line.split(" ")
            new_interval = int(secs)
            if new_interval != self.interval:
                log.debug("Session interval changed to %d" % new_interval)
                self.interval = new_interval

    def digest(self, challenge):
        pass_hash = md5.new(self.password)
        sess_hash = md5.new(pass_hash.hexdigest() + challenge)
        return sess_hash.hexdigest()

    def submit(self, cache):
        while cache.subs:
            args = { 'u': self.user, 's': self.session_key }
            post_data = [urllib.urlencode(args)]
            for i, sub in enumerate(cache.subs[-SUB_CHUNK_SIZE:]):
                args = {}
                args['a[%d]' % i] =  sub.artist.encode('utf-8')
                args['t[%d]' % i] =  sub.title.encode('utf-8')
                args['l[%d]' % i] =  str(sub.length)
                args['i[%d]' % i] =  lastfm.asyaml.format_time(sub.time)
                if hasattr(sub, 'album'):
                    args['b[%d]' % i] = sub.album.encode('utf-8')
                else:
                    args['b[%d]' % i] = ''
                if hasattr(sub, 'mbid'):
                    args['m[%d]' % i] = (sub.mbid)
                else:
                    args['m[%d]' % i] = ''
                self.log.info("Submitting: %s" % sub.shortname())
                post_data.append(urllib.urlencode(args))

            post_str = '&'.join(post_data)
            self.log.debug("POST data: %s" % post_str)
            try:
                response = urllib.urlopen(self.submit_url, post_str)
            except IOError, e:
                raise SubTimeoutError(e)

            failed = False
            status_line = response.readline().strip()

            if status_line == "OK":
                self.log.info("Submission(s) accepted")
                # now, and only now, we do our side effect.
                cache.subs = cache.subs[-SUB_CHUNK_SIZE:]
            elif status_line == "BADAUTH":
                self.connected = False
                raise SessionError("incorrect password")
            elif status_line.startswith("FAILED"):
                try:
                    failed, reason = status_line.split(" ")
                except ValueError:
                    reason = "unknown"
                raise InvalidSubError("failed: %s" % reason)
            else:
                raise InvalidSubError("could not parse response: %s" %
                    status_line)

            self.read_interval(response)
            time.sleep(self.interval)

if __name__ == '__main__':
    shortopts = 'u:p:d'
    longopts = ['user=', 'password=', 'debug']

    try:
        opts, args = getopt.getopt(sys.argv[1:], shortopts, longopts)
    except getopt.GetoptError, e:
        print >>sys.stderr, "error: %s" % e
        sys.exit(1)
    if args:
        print >>sys.stderr, "extra args: %s" % ' '.join(args)
        sys.exit(1)

    user = None
    password = None
    debug = False

    try: user = os.environ['LASTFM_USER']
    except KeyError: pass
    try: password = os.environ['LASTFM_PASSWORD']
    except KeyError: pass

    for opt, arg in opts:
        if opt in ('--user', '-u'):
            user = arg
        elif opt in ('--password', '-p'):
            password = arg
        elif opt in ('--debug', '-d'):
            debug = True
        else:
            print >>sys.stderr, "unknown option: %s", opt
            sys.exit(1)

    if not (user and password):
        print >>sys.stderr, "error: user and password are required"
        sys.exit(1)

    def handle_signal(signum, frame):
        log.info("Caught signal %d, exiting" % signum)
        sys.exit(0)

    for signum in (signal.SIGTERM, signal.SIGINT):
        signal.signal(signum, handle_signal)

    log = lastfm.logger.create_log("lastfmsubmitd", debug)
    log.info("Last.fm Submission Daemon starting")

    session = LastFmSession(log, user, password)
    throttle = SessionThrottle(log)
    fifo = SubFifo(log, lastfm.SUBMITD_FIFO)
    cache = SubCache(log, lastfm.SUBMITD_CACHE)
    if cache.subs:
        log.info("Read %d subs from cache", len(cache.subs))

    while True:
        if not session.connected:
            if throttle.ready():
                try:
                    session.handshake()
                except HandshakeError, e:
                    log.error("Handshake failed: %s" % e)
                    throttle.backoff()
            else:
                throttle.sleep(SLEEP_TIME)

        if session.connected and cache.subs:
            if throttle.ready():
                try:
                    log.debug("Attempting submit, %d subs" % len(cache.subs))
                    session.submit(cache)
                    log.debug("Done, %d remain in cache" % len(cache.subs))
                except SessionError, e:
                    self.log.error("Session failed: %s" % e)
                    throttle.backoff()
                except InvalidSubError, e:
                    self.log.error("Submission failed: %s" % e)
                    throttle.backoff()
                except SubTimeoutError:
                    self.log.error("Submission timed out")
                    throttle.backoff()
            else:
                throttle.sleep(SLEEP_TIME)

        try:
            data = fifo.select(FIFO_TIMEOUT)
            if data:
                incoming = lastfm.asyaml.Parser(data)
                count = 0
                for sub in incoming.parse():
                    cache.subs.append(sub)
                    count += 1
                if count:
                    log.info("Read %d subs from fifo" %
                        (count, lastfm.SUBMITD_FIFO))
            else:
                throttle.add(FIFO_TIMEOUT)
        except ValueError, e:
            log.error("Discarding invalid data: %s" % e)
            pass
