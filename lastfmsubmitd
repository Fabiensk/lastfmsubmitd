#!/usr/bin/python

import sys
import os
import stat
import time
import getopt
import select
import socket
import urllib
import md5
import signal

import lastfm
import lastfm.logger
import lastfm.asyaml

# This is only a band-aid until a proper solution is implemented.
socket.setdefaulttimeout(300)

CLIENT_ID = "lsd"
CLIENT_VERSION = "0.15"
PROTOCOL_VERSION = "1.1"

HANDSHAKE_URL_BASE = "http://post.audioscrobbler.com/"
DEF_INTERVAL = 1

SUB_CHUNK_SIZE = 10

SLEEP_TIME = 15
INITIAL_BACKOFF = 60

FIFO_TIMEOUT = 5

class HandshakeError(Exception): pass
class SubTimeoutError(Exception): pass
class SessionError(Exception): pass
class InvalidSubError(Exception): pass

class SessionThrottle:
    """Very simple throttler that ensures we sleep long enough between network
    requests, but lets you sleep a little at a time and then wake to do other
    stuff. Only keeps track of how long it has slept, not the actual time
    elapsed. You can mess with time.slept to simulate a sleep."""

    def __init__(self, log):
        self.log = log
        self.reset()

    def reset(self):
        self.slept = 0
        self.sleep_until = 0

    def ready(self):
        self.log.debug("Slept %d of %d secs" % (self.slept, self.sleep_until))
        return self.slept >= self.sleep_until

    def backoff(self):
        self.slept = 0
        if self.sleep_until < INITIAL_BACKOFF:
            self.sleep_until = INITIAL_BACKOFF
        else:
            self.sleep_until *= 2
        self.log.info("Backing off, will retry in %d:%02d" %
            divmod(self.sleep_until, 60))

    def sleep(self, secs):
        secs = min(secs, self.sleep_until - self.slept)
        time.sleep(secs)
        self.slept += secs

class SubCache:
    """Holds submissions while we are running, and saves them to persistent
    storage on exit."""

    def __init__(self, log, filename):
        self.log = log
        self.subs = []
        try:
            cache = file(filename)
            stored = lastfm.asyaml.Parser(cache.read())
            self.subs += stored.items
        except IOError:
            pass

    def dump(self, filename):
        try:
            log.info("Saving %d sub(s) to cache" % len(cache.subs))
            out = file(filename, 'w')
            out.write("\n".join(map(str, self.subs)))
            out.write("\n")
            self.subs = []
        except IOError:
            self.log.error("Cannot write to %s, discarding %d sub(s)" %
                (filename, len(self.subs)))

class SubFifo:
    """Reads one writer at a time from our fifo, making sure it actually
    exists first."""

    def __init__(self, log, fifoname):
        self.log = log
        self.fifoname = fifoname
        try:
            if not stat.S_ISFIFO(os.stat(fifoname).st_mode):
                self.log.error("%s exists but is not a fifo, exiting")
                sys.exit(1)
        except OSError:
            self.log.debug("Creating %s" % fifoname)
            os.mkfifo(self.fifoname)

    def select(self, timeout):
        fd = os.open(self.fifoname, os.O_NONBLOCK)
        rx, wx, ex = select.select([fd], [], [], timeout)
        data = []
        if fd in rx:
            while True:
                chunk = os.read(fd, 4096)
                if chunk:
                    self.log.debug("Read %d bytes" % len(chunk))
                    data.append(chunk)
                    rx, wx, ex = select.select([fd], [], [], timeout)
                else:
                    break
        os.close(fd)
        return ''.join(data)

class LastFmSession:
    def __init__(self, log, user, password):
        self.log = log
        self.user = user
        self.password = password
        self.connected = False
        self.interval = DEF_INTERVAL
        self.uncommitted_subs = []
        self.handshake_url = self.make_handshake_url(user)
        self.submit_url = None

    def make_handshake_url(self, user):
        args = {
            'hs': 'true',
            'p': PROTOCOL_VERSION,
            'c': CLIENT_ID,
            'v': CLIENT_VERSION,
            'u': user,
            }
        return "?".join([HANDSHAKE_URL_BASE, urllib.urlencode(args)])

    def handshake(self):
        self.log.debug("Handshake URL: %s" % self.handshake_url)

        try:
            response = urllib.urlopen(self.handshake_url)
            status_line = response.readline().strip()
        except IOError, e:
            raise HandshakeError(e)

        if status_line == "UPTODATE":
            self.read_submit_url(response)
        elif status_line.startswith("UPDATE"):
            try:
                msg, url = status_line.split(" ", 1)
                self.log.warning("Plugin is out of date: %s" % msg)
                self.log.info("Please go to %s to upgrade" % url)
            except ValueError:
                self.log.warning("Plugin is out of date")
            self.read_submit_url(response)
        elif status_line == "BADUSER":
            raise HandshakeError("bad username")
        elif status_line.startswith("FAILED"):
            try:
                failed, reason = status_line.split(" ", 1)
            except ValueError:
                reason = "unknown: '%s'" % status_line
            raise HandshakeError(reason)
        else:
            raise HandshakeError("could not parse response: %s" % status_line)

        self.connected = True
        self.read_interval(response)
        time.sleep(self.interval)

    def read_submit_url(self, response):
        challenge = response.readline().strip()
        self.session_key = self.digest(challenge)
        self.submit_url = response.readline().strip()
        self.log.info("Handshake sucessful")
        self.log.debug("Submit URL: %s" % self.submit_url)

    def read_interval(self, response):
        interval_line = response.readline().strip()
        if interval_line and interval_line.startswith("INTERVAL"):
            msg, secs = interval_line.split(" ", 1)
            new_interval = int(secs)
            if new_interval != self.interval:
                log.debug("Session interval changed to %d" % new_interval)
                self.interval = new_interval

    def digest(self, challenge):
        pass_hash = md5.new(self.password)
        sess_hash = md5.new(pass_hash.hexdigest() + challenge)
        return sess_hash.hexdigest()

    def submit(self, cache):
        while cache.subs:
            self.log.info("Submitting %d song(s)" %
                len(cache.subs[:SUB_CHUNK_SIZE]))

            args = { 'u': self.user, 's': self.session_key }
            post_data = [urllib.urlencode(args)]
            for i, sub in enumerate(cache.subs[:SUB_CHUNK_SIZE]):
                args = {}
                args['a[%d]' % i] =  sub.artist.encode('utf-8')
                args['t[%d]' % i] =  sub.title.encode('utf-8')
                args['l[%d]' % i] =  str(sub.length)
                args['i[%d]' % i] =  lastfm.asyaml.format_time(sub.time)
                if hasattr(sub, 'album'):
                    args['b[%d]' % i] = sub.album.encode('utf-8')
                else:
                    args['b[%d]' % i] = ''
                if hasattr(sub, 'mbid'):
                    args['m[%d]' % i] = (sub.mbid)
                else:
                    args['m[%d]' % i] = ''
                self.log.debug("Submitting: %s" % sub.shortname())
                post_data.append(urllib.urlencode(args))

            post_str = '&'.join(post_data)
            self.log.debug("POST data: %s" % post_str)
            try:
                response = urllib.urlopen(self.submit_url, post_str)
            except IOError, e:
                raise SubTimeoutError(e)

            failed = False
            status_line = response.readline().strip()

            if status_line == "OK":
                self.log.info("Submission(s) accepted")
                # Now, and only now, we do our side effect.
                cache.subs = cache.subs[SUB_CHUNK_SIZE:]
            elif status_line == "BADAUTH":
                self.connected = False
                raise SessionError("incorrect password")
            elif status_line.startswith("FAILED"):
                try:
                    failed, reason = status_line.split(" ", 1)
                except ValueError:
                    reason = "unknown: '%s'" % status_line
                raise InvalidSubError(reason)
            else:
                raise InvalidSubError("could not parse response: %s" %
                    status_line)

            self.read_interval(response)
            time.sleep(self.interval)

if __name__ == '__main__':
    shortopts = 'u:p:d'
    longopts = ['user=', 'password=', 'debug']

    try:
        opts, args = getopt.getopt(sys.argv[1:], shortopts, longopts)
    except getopt.GetoptError, e:
        print >>sys.stderr, "error: %s" % e
        sys.exit(1)
    if args:
        print >>sys.stderr, "extra args: %s" % ' '.join(args)
        sys.exit(1)

    user = None
    password = None
    debug = False

    try: user = os.environ['LASTFM_USER']
    except KeyError: pass
    try: password = os.environ['LASTFM_PASSWORD']
    except KeyError: pass

    for opt, arg in opts:
        if opt in ('--user', '-u'):
            user = arg
        elif opt in ('--password', '-p'):
            password = arg
        elif opt in ('--debug', '-d'):
            debug = True
        else:
            print >>sys.stderr, "unknown option: %s", opt
            sys.exit(1)

    if not (user and password):
        print >>sys.stderr, "error: user and password are required"
        sys.exit(1)

    log = lastfm.logger.create_log("lastfmsubmitd", debug)
    log.info("Last.fm Submission Daemon starting")

    session = LastFmSession(log, user, password)
    throttle = SessionThrottle(log)
    fifo = SubFifo(log, lastfm.SUBMITD_FIFO)
    cache = SubCache(log, lastfm.SUBMITD_CACHE)
    if cache.subs:
        log.info("Read %d sub(s) from cache", len(cache.subs))

    def handle_signal(signum, frame):
        log.info("Caught signal %d, exiting" % signum)
        cache.dump(lastfm.SUBMITD_CACHE)
        sys.exit(0)

    for signum in (signal.SIGTERM, signal.SIGINT):
        signal.signal(signum, handle_signal)

    while True:
        if not session.connected:
            if throttle.ready():
                try:
                    session.handshake()
                    throttle.reset()
                except HandshakeError, e:
                    log.error("Handshake failed: %s" % e)
                    throttle.backoff()
            else:
                throttle.sleep(SLEEP_TIME)

        if session.connected and cache.subs:
            if throttle.ready():
                try:
                    log.debug("Attempting submit, %d sub(s)" %
                        len(cache.subs))
                    session.submit(cache)
                    log.debug("Done, %d remain in cache" % len(cache.subs))
                    throttle.reset()
                except SessionError, e:
                    log.error("Session failed: %s" % e)
                    throttle.backoff()
                except InvalidSubError, e:
                    log.error("Submission failed: %s" % e)
                    throttle.backoff()
                except SubTimeoutError:
                    log.error("Submission timed out")
                    throttle.backoff()
            else:
                throttle.sleep(SLEEP_TIME)

        try:
            data = fifo.select(FIFO_TIMEOUT)
            while data:
                # We may have timed out for a few seconds, but whatever.
                incoming = lastfm.asyaml.Parser(data)
                if incoming.items:
                    cache.subs += incoming.items
                    log.debug("Read %d sub(s) from fifo, %d total" %
                        (len(incoming.items), len(cache.subs)))
                data = fifo.select(FIFO_TIMEOUT)
            else:
                # We did time out, so adjust the throttle accordingly.
                throttle.slept += FIFO_TIMEOUT
        except ValueError, e:
            log.error("Discarding invalid data: %s" % e)
